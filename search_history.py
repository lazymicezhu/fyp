#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
搜索历史管理模块
提供搜索历史的存储、管理和智能建议功能
支持搜索频率统计、关键词提取和智能排序
"""

import json
import os
import re
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple
from collections import Counter, defaultdict
import difflib

from config import config
from exceptions import safe_execute, SearchError, error_handler

class SearchHistory:
    """
    搜索历史管理类
    负责搜索历史的存储、检索、分析和智能建议
    提供搜索频率统计、热门关键词分析等高级功能
    """
    
    def __init__(self, history_file: Optional[str] = None):
        """
        初始化搜索历史管理器
        
        Args:
            history_file: 历史文件路径，如果为None则使用配置中的默认路径
        """
        self.history_file = history_file or config.SEARCH["history_file"]
        self.max_history = config.SEARCH["max_history"]
        
        # 搜索历史数据结构
        self.history_data = {
            "searches": [],      # 搜索记录列表
            "statistics": {},    # 搜索统计信息
            "settings": {        # 历史设置
                "max_history": self.max_history,
                "created_at": datetime.now().isoformat(),
                "version": "1.0"
            }
        }
        
        # 内存中的索引和缓存
        self.search_frequency = Counter()           # 搜索频率计数
        self.keyword_frequency = Counter()          # 关键词频率计数
        self.recent_searches = []                   # 最近搜索缓存
        self.search_results_cache = {}              # 搜索结果缓存
        
        # 加载历史数据
        self.load_history()
        self._build_indexes()
    
    @safe_execute(SearchError, default_return=False)
    def load_history(self) -> bool:
        """
        从文件加载搜索历史
        如果文件不存在或格式错误，创建新的历史文件
        
        Returns:
            bool: 加载是否成功
        """
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # 验证数据格式
                if self._validate_history_data(data):
                    self.history_data = data
                    print(f"已加载 {len(self.history_data['searches'])} 条搜索历史")\n                    return True\n                else:\n                    print("历史文件格式无效，将创建新的历史文件")\n                    return self._create_new_history_file()\n            else:\n                print("搜索历史文件不存在，创建新文件")\n                return self._create_new_history_file()\n                \n        except json.JSONDecodeError as e:\n            print(f"搜索历史文件JSON格式错误: {e}")\n            return self._create_new_history_file()\n        except Exception as e:\n            raise SearchError(f"加载搜索历史失败: {str(e)}", search_type="history_load")\n    \n    def _validate_history_data(self, data: Dict) -> bool:\n        """\n        验证历史数据格式\n        \n        Args:\n            data: 历史数据字典\n            \n        Returns:\n            bool: 数据格式是否有效\n        """\n        try:\n            # 检查必要的键\n            required_keys = ["searches", "statistics", "settings"]\n            if not all(key in data for key in required_keys):\n                return False\n            \n            # 检查searches是否为列表\n            if not isinstance(data["searches"], list):\n                return False\n            \n            # 检查每个搜索记录的格式\n            for search in data["searches"]:\n                if not isinstance(search, dict):\n                    return False\n                required_search_keys = ["query", "timestamp"]\n                if not all(key in search for key in required_search_keys):\n                    return False\n            \n            return True\n            \n        except Exception:\n            return False\n    \n    def _create_new_history_file(self) -> bool:\n        """\n        创建新的历史文件\n        \n        Returns:\n            bool: 创建是否成功\n        """\n        try:\n            self.history_data = {\n                "searches": [],\n                "statistics": {},\n                "settings": {\n                    "max_history": self.max_history,\n                    "created_at": datetime.now().isoformat(),\n                    "version": "1.0"\n                }\n            }\n            return self.save_history()\n        except Exception as e:\n            print(f"创建新历史文件失败: {e}")\n            return False\n    \n    def _build_indexes(self):\n        """\n        构建内存索引\n        分析历史数据，构建搜索频率、关键词频率等索引\n        """\n        try:\n            self.search_frequency.clear()\n            self.keyword_frequency.clear()\n            self.recent_searches.clear()\n            \n            searches = self.history_data.get("searches", [])\n            \n            # 按时间排序\n            searches.sort(key=lambda x: x.get("timestamp", ""), reverse=True)\n            \n            # 构建各种索引\n            for search in searches:\n                query = search.get("query", "").strip()\n                if not query:\n                    continue\n                \n                # 搜索频率统计\n                self.search_frequency[query] += 1\n                \n                # 关键词提取和频率统计\n                keywords = self._extract_keywords(query)\n                for keyword in keywords:\n                    self.keyword_frequency[keyword] += 1\n                \n                # 最近搜索（限制数量）\n                if len(self.recent_searches) < 50:\n                    if query not in [s.get("query") for s in self.recent_searches]:\n                        self.recent_searches.append(search)\n            \n            print(f"索引构建完成: {len(self.search_frequency)} 个唯一搜索, {len(self.keyword_frequency)} 个关键词")\n            \n        except Exception as e:\n            error_handler.handle_error(\n                SearchError(f"构建搜索索引失败: {str(e)}", search_type="index_build"),\n                "_build_indexes"\n            )\n    \n    def _extract_keywords(self, query: str) -> List[str]:\n        """\n        从查询中提取关键词\n        使用简单的分词和过滤逻辑\n        \n        Args:\n            query: 搜索查询字符串\n            \n        Returns:\n            List[str]: 关键词列表\n        """\n        try:\n            # 简单的中英文分词\n            # 去除标点符号，按空格和常见分隔符分割\n            import string\n            \n            # 移除标点符号\n            translator = str.maketrans("", "", string.punctuation)\n            cleaned_query = query.translate(translator)\n            \n            # 分割成词\n            words = re.split(r'[\\s,，。；;]+', cleaned_query.lower())\n            \n            # 过滤短词和停用词\n            stop_words = {'的', '了', '在', '是', '和', '与', '或', '但', '而且', 'a', 'an', 'the', 'and', 'or', 'but'}\n            keywords = [word.strip() for word in words \n                       if len(word.strip()) > 1 and word.strip() not in stop_words]\n            \n            return keywords\n            \n        except Exception as e:\n            print(f"关键词提取失败: {e}")\n            return [query]  # 如果提取失败，返回原查询\n    \n    @safe_execute(SearchError, default_return=False)\n    def add_search(self, query: str, result_count: int = 0, success: bool = True) -> bool:\n        """\n        添加搜索记录\n        \n        Args:\n            query: 搜索查询\n            result_count: 搜索结果数量\n            success: 搜索是否成功\n            \n        Returns:\n            bool: 添加是否成功\n        """\n        if not query or not query.strip():\n            return False\n        \n        try:\n            query = query.strip()\n            timestamp = datetime.now().isoformat()\n            \n            # 创建搜索记录\n            search_record = {\n                "query": query,\n                "timestamp": timestamp,\n                "result_count": result_count,\n                "success": success,\n                "session_id": self._get_session_id()\n            }\n            \n            # 如果查询已存在，移除旧记录\n            self.history_data["searches"] = [\n                s for s in self.history_data["searches"] \n                if s.get("query") != query\n            ]\n            \n            # 添加新记录到开头\n            self.history_data["searches"].insert(0, search_record)\n            \n            # 限制历史记录数量\n            if len(self.history_data["searches"]) > self.max_history:\n                self.history_data["searches"] = self.history_data["searches"][:self.max_history]\n            \n            # 更新统计信息\n            self._update_statistics()\n            \n            # 重建索引\n            self._build_indexes()\n            \n            # 保存到文件\n            return self.save_history()\n            \n        except Exception as e:\n            raise SearchError(f"添加搜索记录失败: {str(e)}", query=query, search_type="history_add")\n    \n    def _get_session_id(self) -> str:\n        """\n        获取会话ID\n        用于区分不同的搜索会话\n        \n        Returns:\n            str: 会话ID\n        """\n        # 简单的会话ID生成：使用日期和小时\n        return datetime.now().strftime("%Y%m%d_%H")\n    \n    def _update_statistics(self):\n        """\n        更新统计信息\n        计算各种搜索统计指标\n        """\n        try:\n            searches = self.history_data["searches"]\n            total_searches = len(searches)\n            \n            if total_searches == 0:\n                return\n            \n            # 基本统计\n            successful_searches = sum(1 for s in searches if s.get("success", True))\n            total_results = sum(s.get("result_count", 0) for s in searches)\n            \n            # 时间统计\n            now = datetime.now()\n            today_searches = sum(1 for s in searches \n                               if self._is_same_date(s.get("timestamp"), now.isoformat()))\n            \n            week_ago = now - timedelta(days=7)\n            week_searches = sum(1 for s in searches \n                              if self._parse_timestamp(s.get("timestamp")) >= week_ago)\n            \n            # 更新统计数据\n            self.history_data["statistics"] = {\n                "total_searches": total_searches,\n                "successful_searches": successful_searches,\n                "success_rate": successful_searches / total_searches if total_searches > 0 else 0,\n                "total_results": total_results,\n                "average_results": total_results / successful_searches if successful_searches > 0 else 0,\n                "today_searches": today_searches,\n                "week_searches": week_searches,\n                "last_updated": datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            print(f"更新统计信息失败: {e}")\n    \n    def _is_same_date(self, timestamp_str: str, reference_str: str) -> bool:\n        """\n        检查两个时间戳是否在同一天\n        \n        Args:\n            timestamp_str: 时间戳字符串\n            reference_str: 参考时间戳字符串\n            \n        Returns:\n            bool: 是否在同一天\n        """\n        try:\n            ts1 = self._parse_timestamp(timestamp_str)\n            ts2 = self._parse_timestamp(reference_str)\n            return ts1.date() == ts2.date()\n        except Exception:\n            return False\n    \n    def _parse_timestamp(self, timestamp_str: str) -> datetime:\n        """\n        解析时间戳字符串\n        \n        Args:\n            timestamp_str: 时间戳字符串\n            \n        Returns:\n            datetime: 解析后的时间对象\n        """\n        try:\n            # 尝试多种时间格式\n            formats = [\n                "%Y-%m-%dT%H:%M:%S.%f",\n                "%Y-%m-%dT%H:%M:%S",\n                "%Y-%m-%d %H:%M:%S",\n                "%Y-%m-%d"\n            ]\n            \n            for fmt in formats:\n                try:\n                    return datetime.strptime(timestamp_str, fmt)\n                except ValueError:\n                    continue\n            \n            # 如果都失败了，返回当前时间\n            return datetime.now()\n            \n        except Exception:\n            return datetime.now()\n    \n    @safe_execute(SearchError, default_return=False)\n    def save_history(self) -> bool:\n        """\n        保存搜索历史到文件\n        \n        Returns:\n            bool: 保存是否成功\n        """\n        try:\n            # 创建备份\n            if os.path.exists(self.history_file):\n                backup_file = self.history_file + ".backup"\n                with open(self.history_file, 'r', encoding='utf-8') as src:\n                    with open(backup_file, 'w', encoding='utf-8') as dst:\n                        dst.write(src.read())\n            \n            # 保存当前数据\n            with open(self.history_file, 'w', encoding='utf-8') as f:\n                json.dump(self.history_data, f, indent=2, ensure_ascii=False)\n            \n            return True\n            \n        except Exception as e:\n            raise SearchError(f"保存搜索历史失败: {str(e)}", search_type="history_save")\n    \n    def get_recent_searches(self, limit: int = 10) -> List[Dict]:\n        """\n        获取最近搜索记录\n        \n        Args:\n            limit: 返回记录数量限制\n            \n        Returns:\n            List[Dict]: 最近搜索记录列表\n        """\n        return self.recent_searches[:limit]\n    \n    def get_popular_searches(self, limit: int = 10) -> List[Tuple[str, int]]:\n        """\n        获取热门搜索词\n        按搜索频率排序\n        \n        Args:\n            limit: 返回数量限制\n            \n        Returns:\n            List[Tuple[str, int]]: (搜索词, 频率) 的列表\n        """\n        return self.search_frequency.most_common(limit)\n    \n    def get_popular_keywords(self, limit: int = 20) -> List[Tuple[str, int]]:\n        """\n        获取热门关键词\n        按关键词频率排序\n        \n        Args:\n            limit: 返回数量限制\n            \n        Returns:\n            List[Tuple[str, int]]: (关键词, 频率) 的列表\n        """\n        return self.keyword_frequency.most_common(limit)\n    \n    def get_search_suggestions(self, partial_query: str, limit: int = 5) -> List[str]:\n        """\n        获取搜索建议\n        基于历史搜索和模糊匹配提供建议\n        \n        Args:\n            partial_query: 部分查询字符串\n            limit: 建议数量限制\n            \n        Returns:\n            List[str]: 搜索建议列表\n        """\n        try:\n            if not partial_query or len(partial_query.strip()) < 2:\n                return []\n            \n            partial_query = partial_query.strip().lower()\n            suggestions = []\n            \n            # 从历史搜索中查找匹配项\n            for search_term, frequency in self.search_frequency.items():\n                if partial_query in search_term.lower():\n                    suggestions.append((search_term, frequency, 1.0))  # (term, freq, score)\n            \n            # 使用difflib进行模糊匹配\n            all_searches = list(self.search_frequency.keys())\n            fuzzy_matches = difflib.get_close_matches(\n                partial_query, all_searches, n=limit*2, cutoff=0.3\n            )\n            \n            for match in fuzzy_matches:\n                if match not in [s[0] for s in suggestions]:\n                    frequency = self.search_frequency[match]\n                    # 计算相似度得分\n                    similarity = difflib.SequenceMatcher(None, partial_query, match.lower()).ratio()\n                    suggestions.append((match, frequency, similarity))\n            \n            # 按频率和相似度排序\n            suggestions.sort(key=lambda x: (x[2], x[1]), reverse=True)\n            \n            return [s[0] for s in suggestions[:limit]]\n            \n        except Exception as e:\n            error_handler.handle_error(\n                SearchError(f"获取搜索建议失败: {str(e)}", query=partial_query, search_type="suggestion"),\n                "get_search_suggestions"\n            )\n            return []\n    \n    def clear_history(self) -> bool:\n        """\n        清除搜索历史\n        \n        Returns:\n            bool: 清除是否成功\n        """\n        try:\n            self.history_data["searches"] = []\n            self.history_data["statistics"] = {}\n            \n            # 清除内存索引\n            self.search_frequency.clear()\n            self.keyword_frequency.clear()\n            self.recent_searches.clear()\n            self.search_results_cache.clear()\n            \n            return self.save_history()\n            \n        except Exception as e:\n            error_handler.handle_error(\n                SearchError(f"清除搜索历史失败: {str(e)}", search_type="history_clear"),\n                "clear_history"\n            )\n            return False\n    \n    def get_statistics(self) -> Dict:\n        """\n        获取搜索统计信息\n        \n        Returns:\n            Dict: 统计信息字典\n        """\n        return self.history_data.get("statistics", {})\n    \n    def export_history(self, export_file: str) -> bool:\n        """\n        导出搜索历史到指定文件\n        \n        Args:\n            export_file: 导出文件路径\n            \n        Returns:\n            bool: 导出是否成功\n        """\n        try:\n            with open(export_file, 'w', encoding='utf-8') as f:\n                json.dump(self.history_data, f, indent=2, ensure_ascii=False)\n            return True\n        except Exception as e:\n            error_handler.handle_error(\n                SearchError(f"导出搜索历史失败: {str(e)}\", search_type=\"history_export\"),\n                \"export_history\"\n            )\n            return False\n    \n    def import_history(self, import_file: str) -> bool:\n        \"\"\"\n        从指定文件导入搜索历史\n        \n        Args:\n            import_file: 导入文件路径\n            \n        Returns:\n            bool: 导入是否成功\n        \"\"\"\n        try:\n            with open(import_file, 'r', encoding='utf-8') as f:\n                imported_data = json.load(f)\n            \n            if self._validate_history_data(imported_data):\n                self.history_data = imported_data\n                self._build_indexes()\n                return self.save_history()\n            else:\n                print(\"导入的历史文件格式无效\")\n                return False\n                \n        except Exception as e:\n            error_handler.handle_error(\n                SearchError(f\"导入搜索历史失败: {str(e)}\", search_type=\"history_import\"),\n                \"import_history\"\n            )\n            return False\n\n\n# 创建全局搜索历史管理实例\nsearch_history = SearchHistory()